{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { useMediaQuery } from 'react-responsive';\nconst isLG = useMediaQuery({\n  query: '(min-device-width: 1200px)'\n});\nconst isMD = useMediaQuery({\n  query: '(min-device-width: 992px)'\n});\nconst isSM = useMediaQuery({\n  query: '(min-device-width: 768px)'\n});\nconst isXS = useMediaQuery({\n  query: '(min-device-width: 500px)'\n});\nconst DIRECTIONS = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n\nconst setLength = () => {\n  let gridLength;\n\n  if (isLG) {\n    gridLength = 700;\n  } else if (isMD) {\n    gridLength = 600;\n  } else if (isSM) {\n    gridLength = 500;\n  } else if (isXS) {\n    gridLength = 400;\n  } else {\n    gridLength = 300;\n  }\n\n  return gridLength;\n};\n\nconst computeCellLength = (gridLength, num) => (gridLength / num).toFixed(2);\n\nexport const gridSlice = createSlice({\n  name: 'grid',\n  initialState: {\n    width: 50,\n    height: 50,\n    grid: [],\n    livingNeighbors: [],\n    count: 0,\n    stage: 0\n  },\n  reducers: {\n    setSize: (state, action) => {\n      state.width = action.payload.width;\n      state.height = action.payload.height;\n    },\n    initializeGridAndNeighbors: state => {\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          row.push(Number(0));\n        }\n\n        state.livingNeighbors.push(row);\n      }\n\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          if (Math.random() < 0.05) {\n            // 1 - living\n            row.push(1);\n            state.count += 1;\n\n            for (let dir of DIRECTIONS) {\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                state.livingNeighbors[x][y] += 1;\n              }\n            }\n          } else {\n            // set it to the max dead state\n            row.push(-10);\n          }\n        }\n\n        state.grid.push(row);\n      }\n\n      state.cellWidth = (setLength() / state.width).toFixed(2);\n      state.cellHeight = (setLength() / state.height).toFixed(2);\n    },\n    toggleCell: (state, action) => {\n      const i = action.payload[0];\n      const j = action.payload[1];\n\n      if (state.grid[i][j] === 1) {\n        state.grid[i][j] = -10;\n        state.count -= 1;\n\n        for (let dir of DIRECTIONS) {\n          let x = Number(i) + Number(dir[0]);\n          let y = Number(j) + Number(dir[1]);\n\n          if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n            state.livingNeighbors[x][y]--;\n          }\n        }\n      } else {\n        state.grid[i][j] = 1;\n        state.count += 1;\n\n        for (let dir of DIRECTIONS) {\n          let x = Number(i) + Number(dir[0]);\n          let y = Number(j) + Number(dir[1]);\n\n          if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n            state.livingNeighbors[x][y] += Number(1);\n          }\n        }\n      }\n    },\n    updateGridAndNeighbors: state => {\n      // deep copy neighbors\n      const newNeighbors = [];\n\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          row.push(state.livingNeighbors[i][j]);\n        }\n\n        newNeighbors.push(row);\n      } // update grid based on their livingneighbors\n      // and also update the count and newNeighbors if necessary\n\n\n      for (let i = 0; i < state.height; i++) {\n        for (let j = 0; j < state.width; j++) {\n          if (state.grid[i][j] === 1 && (state.livingNeighbors[i][j] < 2 || state.livingNeighbors[i][j] > 3)) {\n            state.grid[i][j] = 0;\n            state.count -= 1;\n\n            for (let dir of DIRECTIONS) {\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                newNeighbors[x][y]--;\n              }\n            }\n          } else if (state.grid[i][j] <= 0 && state.livingNeighbors[i][j] === 3) {\n            state.grid[i][j] = 1;\n            state.count += 1;\n\n            for (let dir of DIRECTIONS) {\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                newNeighbors[x][y]++;\n              }\n            }\n          } else if (state.grid[i][j] <= 0 && state.grid[i][j] > -10) {\n            state.grid[i][j] -= 1;\n          }\n        }\n      }\n\n      state.livingNeighbors = newNeighbors;\n      state.stage += 1;\n    },\n    setCellWidth: state => {\n      let gridLength = setLength();\n      state.cellWidth = computeCellLength(gridLength, state.width);\n    },\n    setCellHeight: state => {\n      let gridLength = setLength();\n      state.cellHeight = computeCellLength(gridLength, state.height);\n    },\n    resetGrid: state => {\n      state.width = 50;\n      state.height = 50;\n      state.grid = [];\n      state.livingNeighbors = [];\n      state.count = 0;\n      state.stage = 0;\n    },\n    clearGrid: state => {\n      state.count = 0;\n      state.stage = 0;\n\n      for (let i = 0; i < state.height; i++) {\n        for (let j = 0; j < state.width; j++) {\n          state.grid[i][j] = Number(-10);\n          state.livingNeighbors[i][j] = Number(0);\n        }\n      }\n    }\n  }\n});\nexport const {\n  setSize,\n  initializeGridAndNeighbors,\n  toggleCell,\n  updateGridAndNeighbors,\n  resetGrid,\n  clearGrid\n} = gridSlice.actions;\nexport const selectWidth = state => state.grid.width;\nexport const selectHeight = state => state.grid.height;\nexport const selectCount = state => state.grid.count;\nexport const selectGrid = state => state.grid.grid;\nexport const selectStage = state => state.grid.stage;\nexport const selectCellWidth = state => state.grid.cellWidth;\nexport const selectCellHeight = state => state.grid.cellHeight;\nexport default gridSlice.reducer;","map":{"version":3,"sources":["/Users/peilinguo/Documents/NEU/cs5610/peilin-guo-assignment2/src/game/grid/gridSlice.js"],"names":["createSlice","useMediaQuery","isLG","query","isMD","isSM","isXS","DIRECTIONS","setLength","gridLength","computeCellLength","num","toFixed","gridSlice","name","initialState","width","height","grid","livingNeighbors","count","stage","reducers","setSize","state","action","payload","initializeGridAndNeighbors","i","row","j","push","Number","Math","random","dir","x","y","cellWidth","cellHeight","toggleCell","updateGridAndNeighbors","newNeighbors","setCellWidth","setCellHeight","resetGrid","clearGrid","actions","selectWidth","selectHeight","selectCount","selectGrid","selectStage","selectCellWidth","selectCellHeight","reducer"],"mappings":"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","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\nimport { useMediaQuery } from 'react-responsive';\n\nconst isLG = useMediaQuery({\n    query: '(min-device-width: 1200px)'\n});\nconst isMD = useMediaQuery({\n    query: '(min-device-width: 992px)'\n});\nconst isSM = useMediaQuery({\n    query: '(min-device-width: 768px)'\n});\nconst isXS = useMediaQuery({\n    query: '(min-device-width: 500px)'\n});\n\nconst DIRECTIONS = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [1, 1],\n    [1, -1],\n    [-1, 1],\n    [-1, -1],\n];\n\nconst setLength = () => {\n    let gridLength;\n    if (isLG) {\n        gridLength = 700;\n    } else if (isMD) {\n        gridLength = 600;\n    } else if (isSM) {\n        gridLength = 500;\n    } else if (isXS) {\n        gridLength = 400;\n    } else {\n        gridLength = 300;\n    }\n    return gridLength;\n};\n\nconst computeCellLength = (gridLength, num) => (gridLength / num).toFixed(2);\n\n\nexport const gridSlice = createSlice({\n    name: 'grid',\n    initialState: {\n        width: 50,\n        height: 50,\n        grid: [],\n        livingNeighbors: [],\n        count: 0,\n        stage: 0,\n    },\n    reducers: {\n        setSize: (state, action) => {\n            state.width = action.payload.width;\n            state.height = action.payload.height;\n        },\n        initializeGridAndNeighbors: state => {\n            for (let i = 0; i < state.height; i++) {\n                let row = [];\n                for (let j = 0; j < state.width; j++) {\n                    row.push(Number(0));\n                }\n                state.livingNeighbors.push(row);\n            }\n            for (let i = 0; i < state.height; i++) {\n                let row = [];\n                for (let j = 0; j < state.width; j++) {\n                    if (Math.random() < 0.05) {\n                        // 1 - living\n                        row.push(1);\n                        state.count += 1;\n                        for (let dir of DIRECTIONS) {\n                            let x = Number(i) + Number(dir[0]);\n                            let y = Number(j) + Number(dir[1]);\n                            if (\n                                x >= 0 &&\n                                y >= 0 &&\n                                x < state.height &&\n                                y < state.width\n                            ) {\n                                state.livingNeighbors[x][y] += 1;\n                            }\n                        }\n                    } else {\n                        // set it to the max dead state\n                        row.push(-10);\n                    }\n                }\n                state.grid.push(row);\n            }\n            state.cellWidth = (setLength() / state.width).toFixed(2);\n            state.cellHeight =  (setLength() / state.height).toFixed(2);\n        },\n        toggleCell: (state, action) => {\n            const i = action.payload[0];\n            const j = action.payload[1];\n            if (state.grid[i][j] === 1) {\n                state.grid[i][j] = -10;\n                state.count -= 1;\n                for (let dir of DIRECTIONS) {\n                    let x = Number(i) + Number(dir[0]);\n                    let y = Number(j) + Number(dir[1]);\n                    if (\n                        x >= 0 &&\n                        y >= 0 &&\n                        x < state.height &&\n                        y < state.width\n                    ) {\n                        state.livingNeighbors[x][y]--;\n                    }\n                }\n            } else {\n                state.grid[i][j] = 1;\n                state.count += 1;\n                for (let dir of DIRECTIONS) {\n                    let x = Number(i) + Number(dir[0]);\n                    let y = Number(j) + Number(dir[1]);\n                    if (\n                        x >= 0 &&\n                        y >= 0 &&\n                        x < state.height &&\n                        y < state.width\n                    ) {\n                        state.livingNeighbors[x][y] += Number(1);\n                    }\n                }\n            }\n        },\n        updateGridAndNeighbors: state => {\n            // deep copy neighbors\n            const newNeighbors = [];\n            for (let i = 0; i < state.height; i++) {\n                let row = [];\n                for (let j = 0; j < state.width; j++) {\n                    row.push(state.livingNeighbors[i][j]);\n                }\n                newNeighbors.push(row);\n            }\n            // update grid based on their livingneighbors\n            // and also update the count and newNeighbors if necessary\n            for (let i = 0; i < state.height; i++) {\n                for (let j = 0; j < state.width; j++) {\n                    if (\n                        state.grid[i][j] === 1 &&\n                        (state.livingNeighbors[i][j] < 2 ||\n                            state.livingNeighbors[i][j] > 3)\n                    ) {\n                        state.grid[i][j] = 0;\n                        state.count -= 1;\n                        for (let dir of DIRECTIONS) {\n                            let x = Number(i) + Number(dir[0]);\n                            let y = Number(j) + Number(dir[1]);\n                            if (\n                                x >= 0 &&\n                                y >= 0 &&\n                                x < state.height &&\n                                y < state.width\n                            ) {\n                                newNeighbors[x][y]--;\n                            }\n                        }\n                    } else if (\n                        state.grid[i][j] <= 0 &&\n                        state.livingNeighbors[i][j] === 3\n                    ) {\n                        state.grid[i][j] = 1;\n                        state.count += 1;\n                        for (let dir of DIRECTIONS) {\n                            let x = Number(i) + Number(dir[0]);\n                            let y = Number(j) + Number(dir[1]);\n                            if (\n                                x >= 0 &&\n                                y >= 0 &&\n                                x < state.height &&\n                                y < state.width\n                            ) {\n                                newNeighbors[x][y]++;\n                            }\n                        }\n                    } else if (\n                        state.grid[i][j] <= 0 &&\n                        state.grid[i][j] > -10\n                    ) {\n                        state.grid[i][j] -= 1;\n                    }\n                }\n            }\n            state.livingNeighbors = newNeighbors;\n            state.stage += 1;\n        },\n        setCellWidth: state => {\n            let gridLength = setLength();\n            state.cellWidth = computeCellLength(gridLength, state.width);\n        },\n        setCellHeight: state => {\n            let gridLength = setLength();\n            state.cellHeight = computeCellLength(gridLength, state.height);\n        },\n        resetGrid: state => {\n            state.width = 50;\n            state.height = 50;\n            state.grid = [];\n            state.livingNeighbors = [];\n            state.count = 0;\n            state.stage = 0;\n        },\n        clearGrid: state => {\n            state.count = 0;\n            state.stage = 0;\n            for (let i = 0; i < state.height; i++) {\n                for (let j = 0; j < state.width; j++) {\n                    state.grid[i][j] = Number(-10);\n                    state.livingNeighbors[i][j] = Number(0);\n                }\n            }\n        },\n    },\n});\n\nexport const {\n    setSize,\n    initializeGridAndNeighbors,\n    toggleCell,\n    updateGridAndNeighbors,\n    resetGrid,\n    clearGrid,\n} = gridSlice.actions;\n\nexport const selectWidth = state => state.grid.width;\nexport const selectHeight = state => state.grid.height;\nexport const selectCount = state => state.grid.count;\nexport const selectGrid = state => state.grid.grid;\nexport const selectStage = state => state.grid.stage;\nexport const selectCellWidth = state => state.grid.cellWidth;\nexport const selectCellHeight = state => state.grid.cellHeight;\n\nexport default gridSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}