{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst DIRECTIONS = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\nexport const gridSlice = createSlice({\n  name: 'grid',\n  initialState: {\n    width: 0,\n    height: 0,\n    grid: [],\n    livingNeighbors: [],\n    count: 0\n  },\n  reducers: {\n    setSize: (state, action) => {\n      state.width = action.payload.width;\n      state.height = action.payload.height;\n    },\n    initializeGridAndNeighbors: state => {\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          row.push(Number(0));\n        }\n\n        state.livingNeighbors.push(row);\n      }\n\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          if (Math.random() < 0.05) {\n            // 1 - living\n            row.push(1);\n            state.count += 1;\n\n            for (let dir of DIRECTIONS) {\n              console.log(dir);\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n              console.log(x);\n              console.log(y);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                state.livingNeighbors[x][y] += 1;\n              }\n            }\n          } else {\n            // 0 - dead\n            row.push(0);\n          }\n        }\n\n        state.grid.push(row);\n      }\n\n      console.log(state.livingNeighbors[0]);\n    },\n    toggleCell: (state, action) => {\n      const i = action.payload[0];\n      const j = action.payload[1];\n\n      if (state.grid[i][j] === 1) {\n        state.grid[i][j] = 0;\n        state.count -= 1;\n\n        for (let dir of DIRECTIONS) {\n          let x = Number(i) + Number(dir[0]);\n          let y = Number(j) + Number(dir[1]);\n\n          if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n            state.livingNeighbors[x][y]--;\n          }\n        }\n      } else {\n        state.grid[i][j] = 1;\n        state.count += 1;\n\n        for (let dir of DIRECTIONS) {\n          let x = Number(i) + Number(dir[0]);\n          let y = Number(j) + Number(dir[1]);\n\n          if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n            state.livingNeighbors[x][y] += Number(1);\n          }\n        }\n      }\n\n      console.log(state.livingNeighbors[0]);\n    },\n    updateGridAndNeighbors: state => {\n      console.log(\"update\"); // deep copy neighbors\n\n      const newNeighbors = [];\n\n      for (let i = 0; i < state.height; i++) {\n        let row = [];\n\n        for (let j = 0; j < state.width; j++) {\n          row.push(state.livingNeighbors[i][j]);\n        }\n\n        newNeighbors.push(row);\n      } // update grid based on their livingneighbors\n      // and also update the count and newNeighbors if necessary\n\n\n      for (let i = 0; i < state.height; i++) {\n        for (let j = 0; j < state.width; j++) {\n          if (state.grid[i][j] === 1 && (state.livingNeighbors[i][j] < 2 || state.livingNeighbors[i][j] > 3)) {\n            state.grid[i][j] = 0;\n            state.count -= 1;\n\n            for (let dir of DIRECTIONS) {\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                newNeighbors[x][y]--;\n              }\n            }\n          } else if (state.grid[i][j] === 0 && state.livingNeighbors[i][j] === 3) {\n            state.grid[i][j] = 1;\n            state.count += 1;\n\n            for (let dir of DIRECTIONS) {\n              let x = Number(i) + Number(dir[0]);\n              let y = Number(j) + Number(dir[1]);\n\n              if (x >= 0 && y >= 0 && x < state.height && y < state.width) {\n                newNeighbors[x][y]++;\n              }\n            }\n          }\n        }\n      }\n\n      state.livingNeighbors = newNeighbors;\n    },\n    resetGrid: state => {\n      state.grid = [];\n      state.livingNeighbors = [];\n    }\n  }\n});\nexport const {\n  setSize,\n  initializeGridAndNeighbors,\n  toggleCell,\n  updateGridAndNeighbors,\n  resetGrid\n} = gridSlice.actions;\nexport const selectWidth = state => state.grid.width;\nexport const selectHeight = state => state.grid.height;\nexport const selectCount = state => state.grid.count;\nexport const selectGrid = state => state.grid.grid; // export const selectWidth = state => state.width;\n// export const selectHeight = state => state.height;\n// export const selectCount = state => state.count;\n// export const selectGrid = state => state.grid;\n\nexport default gridSlice.reducer;","map":{"version":3,"sources":["/Users/peilinguo/Documents/NEU/cs5610/cs5610-assignments/peilin-guo-assignment2/src/gridSlice.js"],"names":["createSlice","DIRECTIONS","gridSlice","name","initialState","width","height","grid","livingNeighbors","count","reducers","setSize","state","action","payload","initializeGridAndNeighbors","i","row","j","push","Number","Math","random","dir","console","log","x","y","toggleCell","updateGridAndNeighbors","newNeighbors","resetGrid","actions","selectWidth","selectHeight","selectCount","selectGrid","reducer"],"mappings":"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","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nconst DIRECTIONS = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]\n\nexport const gridSlice = createSlice({\n    name:'grid',\n    initialState:{\n        width: 0,\n        height: 0,\n        grid: [],\n        livingNeighbors:[],\n        count: 0\n    },\n    reducers: {\n        setSize: (state, action) => {\n            state.width = action.payload.width;\n            state.height = action.payload.height;\n        },\n        initializeGridAndNeighbors: (state) => {\n            for (let i=0; i<state.height; i++) {\n                let row = [];\n                for (let j=0; j<state.width; j++) {\n                    row.push(Number(0))\n                }\n                state.livingNeighbors.push(row)\n            }\n            for (let i=0; i<state.height; i++) {\n                let row = [];\n                for (let j=0; j<state.width; j++) {\n                    if (Math.random() < 0.05) {\n                        // 1 - living\n                        row.push(1)\n                        state.count += 1\n                        for (let dir of DIRECTIONS) {\n                            console.log(dir)\n                            let x = Number(i) + Number(dir[0])\n                            let y = Number(j) + Number(dir[1])\n                            console.log(x)\n                            console.log(y)\n                            if (x >=0 && y>=0 && x < state.height && y < state.width) {\n                                state.livingNeighbors[x][y]+=1\n                            }\n                        }\n                    } else {\n                        // 0 - dead\n                        row.push(0)\n                    }\n                }\n                state.grid.push(row)\n            }\n            console.log(state.livingNeighbors[0])\n        },\n        toggleCell: (state, action) => {\n            const i = action.payload[0]\n            const j = action.payload[1]\n            if (state.grid[i][j] === 1) {\n                state.grid[i][j] = 0;\n                state.count-= 1;\n                for (let dir of DIRECTIONS) {\n                    let x = Number(i) + Number(dir[0])\n                    let y = Number(j) + Number(dir[1])\n                    if (x >=0 && y>=0 && x<state.height && y<state.width) {\n                        state.livingNeighbors[x][y]--\n                    }\n                }\n            } else {\n                state.grid[i][j] = 1;\n                state.count+= 1;\n                for (let dir of DIRECTIONS) {\n                    let x = Number(i) + Number(dir[0])\n                    let y = Number(j) + Number(dir[1])\n                    if (x >=0 && y>=0 && x<state.height && y<state.width) {\n                        state.livingNeighbors[x][y] += Number(1)\n                    }\n                }\n            }\n            console.log(state.livingNeighbors[0])\n        },\n        updateGridAndNeighbors: (state) => {\n            console.log(\"update\")\n            // deep copy neighbors\n            const newNeighbors = []\n            for (let i=0; i<state.height; i++) {\n                let row = []\n                for (let j=0; j<state.width; j++) {\n                    row.push(state.livingNeighbors[i][j])\n                }\n                newNeighbors.push(row)\n            }\n            // update grid based on their livingneighbors\n            // and also update the count and newNeighbors if necessary\n            for (let i=0; i<state.height; i++) {\n                for (let j=0; j<state.width; j++) {\n                    if (state.grid[i][j]===1 &&\n                        (state.livingNeighbors[i][j] < 2 ||\n                            state.livingNeighbors[i][j] > 3)) {\n                        state.grid[i][j] = 0\n                        state.count -= 1\n                        for (let dir of DIRECTIONS) {\n                            let x = Number(i) + Number(dir[0])\n                            let y = Number(j) + Number(dir[1])\n                            if (x >=0 && y>=0 && x<state.height && y<state.width) {\n                                newNeighbors[x][y]--\n                            }\n                        }\n                    } else if (state.grid[i][j]===0 &&\n                        state.livingNeighbors[i][j] === 3) {\n                            state.grid[i][j] = 1\n                            state.count += 1\n                            for (let dir of DIRECTIONS) {\n                                let x = Number(i) + Number(dir[0])\n                                let y = Number(j) + Number(dir[1])\n                                if (x >=0 && y>=0 && x<state.height && y<state.width) {\n                                    newNeighbors[x][y]++\n                                }\n                            }\n                    }\n                }\n            }\n            state.livingNeighbors = newNeighbors\n        },\n        resetGrid: (state)=>{\n            state.grid = []\n            state.livingNeighbors = []\n        }, \n    }\n});\n\nexport const {setSize,\n    initializeGridAndNeighbors,\n    toggleCell,\n    updateGridAndNeighbors,\n    resetGrid} = gridSlice.actions;\n\nexport const selectWidth = state => state.grid.width;\nexport const selectHeight = state => state.grid.height;\nexport const selectCount = state => state.grid.count;\nexport const selectGrid = state => state.grid.grid;\n\n// export const selectWidth = state => state.width;\n// export const selectHeight = state => state.height;\n// export const selectCount = state => state.count;\n// export const selectGrid = state => state.grid;\n\nexport default gridSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}