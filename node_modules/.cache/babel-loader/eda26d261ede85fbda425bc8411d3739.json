{"ast":null,"code":"class Gradient {\n  constructor(gradients = '', maxNum = 10, colors = ['', ''], intervals = []) {\n    const setColors = props => {\n      if (props.length < 2) {\n        throw new Error(`setGradient should have more than ${props.length} color`);\n      } else {\n        let increment = maxNum / (props.length - 1);\n        let firstGradient = new GradientColor();\n        let lower = 0;\n        let upper = 0 + increment;\n        firstGradient.setGradient(props[0], props[1]);\n        firstGradient.setMidpoint(lower, upper);\n        gradients = [firstGradient];\n        intervals = [{\n          lower,\n          upper\n        }];\n\n        for (let i = 1; i < props.length - 1; i++) {\n          let gradientColor = new GradientColor();\n          let lower = 0 + increment * i;\n          let upper = 0 + increment * (i + 1);\n          gradientColor.setGradient(props[i], props[i + 1]);\n          gradientColor.setMidpoint(lower, upper);\n          gradients[i] = gradientColor;\n          intervals[i] = {\n            lower,\n            upper\n          };\n        }\n\n        colors = props;\n      }\n    };\n\n    this.setGradient = (...props) => {\n      setColors(props);\n      return this;\n    };\n\n    this.getArray = () => {\n      let gradientArray = [];\n\n      for (let j = 0; j < intervals.length; j++) {\n        const interval = intervals[j];\n        const start = interval.lower === 0 ? 1 : Math.ceil(interval.lower);\n        const end = interval.upper === maxNum ? interval.upper + 1 : Math.ceil(interval.upper);\n\n        for (let i = start; i < end; i++) {\n          gradientArray.push(gradients[j].getColor(i));\n        }\n      }\n\n      return gradientArray;\n    };\n\n    this.getColor = props => {\n      if (isNaN(props)) {\n        throw new TypeError(`getColor should be a number`);\n      } else if (props <= 0) {\n        throw new TypeError(`getColor should be greater than ${props}`);\n      } else {\n        let segment = (maxNum - 0) / gradients.length;\n        let index = Math.min(Math.floor((Math.max(props, 0) - 0) / segment), gradients.length - 1);\n        return gradients[index].getColor(props);\n      }\n    };\n\n    this.setMidpoint = maxNumber => {\n      if (!isNaN(maxNumber) && maxNumber >= 0) {\n        maxNum = maxNumber;\n        setColors(colors);\n      } else if (maxNumber <= 0) {\n        throw new RangeError(`midPoint should be greater than ${maxNumber}`);\n      } else {\n        throw new RangeError('midPoint should be a number');\n      }\n\n      return this;\n    };\n  }\n\n}\n\nclass GradientColor {\n  constructor(startColor = '', endColor = '', minNum = 0, maxNum = 10) {\n    this.setGradient = (colorStart, colorEnd) => {\n      startColor = getHexColor(colorStart);\n      endColor = getHexColor(colorEnd);\n    };\n\n    this.setMidpoint = (minNumber, maxNumber) => {\n      minNum = minNumber;\n      maxNum = maxNumber;\n    };\n\n    this.getColor = props => {\n      if (props) {\n        return '#' + generateHex(props, startColor.substring(0, 2), endColor.substring(0, 2)) + generateHex(props, startColor.substring(2, 4), endColor.substring(2, 4)) + generateHex(props, startColor.substring(4, 6), endColor.substring(4, 6));\n      }\n    };\n\n    const generateHex = (number, start, end) => {\n      if (number < minNum) {\n        number = minNum;\n      } else if (number > maxNum) {\n        number = maxNum;\n      }\n\n      let midPoint = maxNum - minNum;\n      let startBase = parseInt(start, 16);\n      let endBase = parseInt(end, 16);\n      let average = (endBase - startBase) / midPoint;\n      let finalBase = Math.round(average * (number - minNum) + startBase);\n      return finalBase.toString(16);\n    };\n\n    const getHexColor = props => {\n      return props.substring(props.length - 6, props.length);\n    };\n  }\n\n}\n\nmodule.exports = Gradient;","map":{"version":3,"sources":["/Users/peilinguo/Documents/NEU/cs5610/cs5610-assignments/peilin-guo-assignment2/node_modules/javascript-color-gradient/src/index.js"],"names":["Gradient","constructor","gradients","maxNum","colors","intervals","setColors","props","length","Error","increment","firstGradient","GradientColor","lower","upper","setGradient","setMidpoint","i","gradientColor","getArray","gradientArray","j","interval","start","Math","ceil","end","push","getColor","isNaN","TypeError","segment","index","min","floor","max","maxNumber","RangeError","startColor","endColor","minNum","colorStart","colorEnd","getHexColor","minNumber","generateHex","substring","number","midPoint","startBase","parseInt","endBase","average","finalBase","round","toString","module","exports"],"mappings":"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","sourcesContent":["class Gradient {\r\n    constructor(gradients = '', maxNum = 10, colors = ['', ''], intervals = []) {\r\n\r\n        const setColors = props => {\r\n            if (props.length < 2) {\r\n                throw new Error(`setGradient should have more than ${props.length} color`);\r\n            } else {\r\n                let increment = maxNum / (props.length - 1);\r\n                let firstGradient = new GradientColor();\r\n                let lower = 0;\r\n                let upper = 0 + increment;\r\n                firstGradient.setGradient(props[0], props[1]);\r\n                firstGradient.setMidpoint(lower, upper);\r\n                gradients = [firstGradient];\r\n                intervals = [{\r\n                    lower,\r\n                    upper\r\n                }];\r\n\r\n                for (let i = 1; i < props.length - 1; i++) {\r\n                    let gradientColor = new GradientColor();\r\n                    let lower = 0 + increment * i;\r\n                    let upper = 0 + increment * (i + 1);\r\n                    gradientColor.setGradient(props[i], props[i + 1]);\r\n                    gradientColor.setMidpoint(lower, upper);\r\n                    gradients[i] = gradientColor;\r\n                    intervals[i] = {\r\n                        lower,\r\n                        upper\r\n                    };\r\n                }\r\n                colors = props;\r\n            }\r\n        }\r\n\r\n        this.setGradient = (...props) => {\r\n            setColors(props);\r\n            return this;\r\n        }\r\n\r\n        this.getArray = () => {\r\n            let gradientArray = [];\r\n            for (let j = 0; j < intervals.length; j++) {\r\n                const interval = intervals[j];\r\n                const start = interval.lower === 0 ? 1 : Math.ceil(interval.lower);\r\n                const end = interval.upper === maxNum ? interval.upper + 1 : Math.ceil(interval.upper);\r\n                for (let i = start; i < end; i++) {\r\n                    gradientArray.push(gradients[j].getColor(i))\r\n                }\r\n            }\r\n            return gradientArray;\r\n        }\r\n\r\n        this.getColor = props => {\r\n            if (isNaN(props)) {\r\n                throw new TypeError(`getColor should be a number`);\r\n            } else if (props <= 0) {\r\n                throw new TypeError(`getColor should be greater than ${props}`);\r\n            } else {\r\n                let segment = (maxNum - 0) / (gradients.length);\r\n                let index = Math.min(Math.floor((Math.max(props, 0) - 0) / segment), gradients.length - 1);\r\n                return gradients[index].getColor(props);\r\n            }\r\n        }\r\n\r\n        this.setMidpoint = (maxNumber) => {\r\n            if (!isNaN(maxNumber) && maxNumber >= 0) {\r\n                maxNum = maxNumber;\r\n                setColors(colors);\r\n            } else if (maxNumber <= 0) {\r\n                throw new RangeError(`midPoint should be greater than ${maxNumber}`);\r\n            } else {\r\n                throw new RangeError('midPoint should be a number');\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n}\r\n\r\nclass GradientColor {\r\n    constructor(startColor = '', endColor = '', minNum = 0, maxNum = 10) {\r\n        this.setGradient = (colorStart, colorEnd) => {\r\n            startColor = getHexColor(colorStart);\r\n            endColor = getHexColor(colorEnd);\r\n        }\r\n\r\n        this.setMidpoint = (minNumber, maxNumber) => {\r\n            minNum = minNumber;\r\n            maxNum = maxNumber;\r\n        }\r\n\r\n        this.getColor = props => {\r\n            if (props) {\r\n                return '#' + generateHex(props, startColor.substring(0, 2), endColor.substring(0, 2)) +\r\n                    generateHex(props, startColor.substring(2, 4), endColor.substring(2, 4)) +\r\n                    generateHex(props, startColor.substring(4, 6), endColor.substring(4, 6));\r\n            }\r\n        }\r\n\r\n        const generateHex = (number, start, end) => {\r\n            if (number < minNum) {\r\n                number = minNum;\r\n            } else if (number > maxNum) {\r\n                number = maxNum;\r\n            }\r\n\r\n            let midPoint = maxNum - minNum;\r\n            let startBase = parseInt(start, 16);\r\n            let endBase = parseInt(end, 16);\r\n            let average = (endBase - startBase) / midPoint;\r\n            let finalBase = Math.round(average * (number - minNum) + startBase);\r\n            return (finalBase.toString(16));\r\n        }\r\n\r\n        const getHexColor = props => {\r\n            return props.substring(props.length - 6, props.length);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Gradient;"]},"metadata":{},"sourceType":"script"}